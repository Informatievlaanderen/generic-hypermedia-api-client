/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var _require = require('../util');

const parseLinkHeader = _require.parseLinkHeader,
      buildHeaders = _require.buildHeaders;

var _require2 = require('../constants');

const LINK_HEADER_REL = _require2.LINK_HEADER_REL;

const JsonLdError = require('../JsonLdError');
const RequestQueue = require('../RequestQueue');

/**
 * Creates a built-in node document loader.
 *
 * @param options the options to use:
 *          secure: require all URLs to use HTTPS.
 *          strictSSL: true to require SSL certificates to be valid,
 *            false not to (default: true).
 *          maxRedirects: the maximum number of redirects to permit, none by
 *            default.
 *          request: the object which will make the request, default is
 *            provided by `https://www.npmjs.com/package/request`.
 *          headers: an object (map) of headers which will be passed as request
 *            headers for the requested document. Accept is not allowed.
 *
 * @return the node document loader.
 */
module.exports = function () {
  let loadDocument = (() => {
    var _ref2 = _asyncToGenerator(function* (url, redirects) {
      if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {
        throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', { code: 'loading document failed', url: url });
      }
      if (secure && url.indexOf('https') !== 0) {
        throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', { code: 'loading document failed', url: url });
      }
      // TODO: disable cache until HTTP caching implemented
      let doc = null; //cache.get(url);
      if (doc !== null) {
        return doc;
      }

      let result;
      try {
        result = yield _request(request, {
          url: url,
          headers: headers,
          strictSSL: strictSSL,
          followRedirect: false
        });
      } catch (e) {
        throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', { code: 'loading document failed', url: url, cause: e });
      }

      var _result = result;
      const res = _result.res,
            body = _result.body;


      doc = { contextUrl: null, documentUrl: url, document: body || null };

      // handle error
      const statusText = http.STATUS_CODES[res.statusCode];
      if (res.statusCode >= 400) {
        throw new JsonLdError('URL could not be dereferenced: ' + statusText, 'jsonld.InvalidUrl', {
          code: 'loading document failed',
          url: url,
          httpStatusCode: res.statusCode
        });
      }

      // handle Link Header
      if (res.headers.link && res.headers['content-type'] !== 'application/ld+json') {
        // only 1 related link header permitted
        const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];
        if (Array.isArray(linkHeader)) {
          throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', { code: 'multiple context link headers', url: url });
        }
        if (linkHeader) {
          doc.contextUrl = linkHeader.target;
        }
      }

      // handle redirect
      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        if (redirects.length === maxRedirects) {
          throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {
            code: 'loading document failed',
            url: url,
            httpStatusCode: res.statusCode,
            redirects: redirects
          });
        }
        if (redirects.indexOf(url) !== -1) {
          throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {
            code: 'recursive context inclusion',
            url: url,
            httpStatusCode: res.statusCode,
            redirects: redirects
          });
        }
        redirects.push(url);
        return loadDocument(res.headers.location, redirects);
      }

      // cache for each redirected URL
      redirects.push(url);
      // TODO: disable cache until HTTP caching implemented
      /*
      for(let i = 0; i < redirects.length; ++i) {
        cache.set(
          redirects[i],
          {contextUrl: null, documentUrl: redirects[i], document: body});
      }
      */

      return doc;
    });

    return function loadDocument(_x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  })();

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { strictSSL: true, maxRedirects: -1, headers: {} };

  let secure = _ref.secure;
  var _ref$strictSSL = _ref.strictSSL;
  let strictSSL = _ref$strictSSL === undefined ? true : _ref$strictSSL;
  var _ref$maxRedirects = _ref.maxRedirects;
  let maxRedirects = _ref$maxRedirects === undefined ? -1 : _ref$maxRedirects,
      request = _ref.request;
  var _ref$headers = _ref.headers;
  let headers = _ref$headers === undefined ? {} : _ref$headers;

  headers = buildHeaders(headers);
  // TODO: use `r2`
  request = request || require('request');
  const http = require('http');
  // TODO: disable cache until HTTP caching implemented
  //const cache = new DocumentCache();

  const queue = new RequestQueue();
  return queue.wrapLoader(function (url) {
    return loadDocument(url, []);
  });
};

function _request(request, options) {
  return new Promise((resolve, reject) => {
    request(options, (err, res, body) => {
      if (err) {
        reject(err);
      } else {
        resolve({ res: res, body: body });
      }
    });
  });
}